#!/usr/bin/python3

import sys;
import time;

T_INS   = 0x00;
T_INT   = 0x01;
T_LAB   = 0x02;
T_REG   = 0x03;
T_DREG  = 0x04;
T_0ID   = 0x05;
T_ADDR  = 0x06;
T_BYTE  = 0x07;
T_STR   = 0x08;
T_IDD   = 0x09;
T_MCR   = 0x0A;
T_EOL   = 0x0B;
T_EOF   = 0x0C;

ASTINS   = 0x00;
ASTBYTES = 0x01;
ASTRES   = 0x02;
ASTBRKH  = 0x03;
ASTEOF   = 0x04;

HUMAN_TOKS = ["INST", "INT", "LABEL", "REG", "DRF-REG", "NAME", "ADDRESS", "BYTES", "STRING", "DRF-NAME", "MCR", "EOL", "EOF"];
HUMAN_AST  = ["INST", "BYTES", "RESERVE", "BRK-HANDLER", "EOF"];

LET    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
LETEXT = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxy0123456789z-_.";
DIG    = "0123456789";
WHI    = " \r\0\t";
DIGEXT = "0123456789ABCDEF";
KEY2   = [
  "lda", "ldb", "ldc", "ldd", "lds", "ldg", "push", "int", "lodsb", "lodgb", "cmp", "inx", "dex", "jme", "jmne", "ret", "jmp",
  "call", "nop", "loop", "cop", "storb", "stgrb", "cpuid", "hlt", "pop", "add", "sub", "div", "brk", "ldds", "re", "rne", "mul",
  "trap", "jl", "jle", "jg", "jge", "str", "mov", "mb", "mw"
];
KEYR   = [
  "ax", "bx", "cx", "dx", "si", "gi", "sp", "bp",
  "ex", "fx", "hx", "lx", "x",  "y",  "ix", "iy"
];

def PrintTokens(toks: list):
  for i,j in enumerate(toks):
    if (len(j) == 2):
      print(f"{i}: {HUMAN_TOKS[j[0]]} {j[1]}");
    elif (len(j) == 1):
      print(f"{i}: {HUMAN_TOKS[j[0]]}");

def PrintAst(toks: list):
  for i in toks:
    print(f"${hex(i[3])[2:].upper():0>4}: {HUMAN_AST[i[0]]} {i[1]} {i[2]}");

def PrintLabs(labs: dict):
  print("\nLabel symbols:");
  for i in labs:
    print(f"{i+':': <30}${hex(labs[i])[2:].upper():0>4}");

def ExportLabs(filename: str, labs: dict, output_file: str):
  with open(output_file, "w") as fl:
    for i in labs:
      fl.write(f"{i}	{hex(labs[i])[2:].upper():0>4}\n");

def ImportLabs(filename: str, labs: dict, import_file: str):
  with open(import_file, "r") as fl:
    for line in fl.read().split("\n"):
      if (line):
        symbol,val = line.split(chr(9));
        labs[symbol] = int(val, base=16);
  return labs;

def OffsetLabs(labs: dict, offset: int):
  for i in labs:
    labs[i] += offset;
  return labs;

# Lexer:
def Lex(prog: str, filename: str):
  prog += "\n\0";
  labelscope: str  = "";
  proglen:    int  = len(prog);
  linenum:    int  = 1;
  toks:       list = [];
  pos:        int  = 0;
  buf:        str  = "";
  while (True):
    if (prog[pos] == "\0"):
      toks.append((T_EOL,));
      toks.append((T_EOF,));
      return toks, 0;
    elif (prog[pos] in ";,"):
      pos += 1;
      while (prog[pos] != "\n"):
        pos += 1;
    elif ((prog[pos] == "/") and (prog[pos+1] == "/")):
      pos += 1;
      while (prog[pos] != "\n"):
        pos += 1;
    elif ((prog[pos] == "/") and (prog[pos+1] == "*")):
      pos += 1;
      while ((prog[pos] != "*") or (prog[pos+1] != "/")):
        pos += 1;
      pos += 1;
    elif (prog[pos] in WHI):
      pos += 1;
    elif (prog[pos] == "\n"):
      if ((toks) and (toks[-1][0] != T_EOL)):
        toks.append((T_EOL,));
      pos += 1;
      linenum += 1;
    elif (prog[pos] in "."): # Local label
      pos += 1;
      while (prog[pos] in LETEXT):
        buf += prog[pos];
        pos += 1;
      if (prog[pos] == ":"):
        toks.append((T_LAB, labelscope+"."+buf));
        pos += 1;
      else:
        toks.append((T_0ID, labelscope+"."+buf));
      buf = "";
    elif (prog[pos] in "%"):
      pos += 1;
      while (prog[pos] in LET):
        buf += prog[pos];
        pos += 1;
      pos += 1;
      if (buf in KEYR):
        toks.append((T_REG, KEYR.index(buf)));
      else:
        print(f"kasm: {filename}:{linenum}:1: Unknown register {buf}");
        exit(1);
      buf = "";
      pos -= 1;
    elif (prog[pos] in DIG):
      while (prog[pos] in DIG):
        buf += prog[pos];
        pos += 1;
      toks.append((T_INT, int(buf, base=10)));
      buf = "";
    elif (prog[pos] == "\""):
      pos += 1;
      while (prog[pos] != "\""):
        if (prog[pos] == "$"):
          buf += "\n";
        elif (prog[pos] == "\n"):
          print(f"kasm: {filename}:{linenum}:1: Unterminated string literal");
          exit(1);
        elif ((prog[pos] == "\\") and (prog[pos+1] == "\"")):
          buf += "\"";
          pos += 1;
        elif (prog[pos] == "^"):
          if (ord(prog[pos+1]) in range(64, 97)):
            buf += chr(ord(prog[pos+1])-64);
          elif (prog[pos+1] in "^$"):
            buf += prog[pos+1];
          pos += 1;
        else:
          buf += prog[pos];
        pos += 1;
      pos += 1;
      toks.append((T_STR, buf.encode()));
      buf = "";
    elif (prog[pos] == "'"):
      pos += 1;
      if (prog[pos] == "$"):
        buf = 10;
      elif ((prog[pos] == "\\") and (prog[pos+1] == "\"")):
        buf = 34;
        pos += 2;
      elif (prog[pos] == "^"):
        if (ord(prog[pos+1]) in range(64, 97)):
          buf = ord(prog[pos+1])-64;
        elif (prog[pos+1] in "^$"):
          buf = ord(prog[pos+1]);
        pos += 1;
      else:
        buf = ord(prog[pos]);
      pos += 1;
      if (prog[pos] != "'"):
        print(f"kasm: {filename}:{linenum}:1: Unterminated character literal");
        exit(1);
      pos += 1;
      toks.append((T_INT, buf));
      buf = "";
    elif (prog[pos] == "^"):
      pos += 1;
      while (prog[pos] in DIGEXT):
        buf += prog[pos];
        pos += 1;
      pos += 1;
      toks.append((T_INT, int(buf, base=16)));
      buf = "";
      # cpos += 1;
    elif (prog[pos] == "$"):
      pos += 1;
      while (prog[pos] in DIGEXT):
        buf += prog[pos];
        pos += 1;
      toks.append((T_INT, int(buf, base=16)));
      buf = "";
    elif (prog[pos] == "*"):
      pos += 1;
      regop = 0;
      if (prog[pos] == "%"):
        regop = 1;
        pos += 1;
      while (prog[pos] in LETEXT):
        buf += prog[pos];
        pos += 1;
      if (regop): # Dereferncing a register bro what :/
        toks.append((T_DREG, KEYR.index(buf))); # GC16X is weird
      else:
        toks.append((T_IDD, buf));
      buf = "";
    elif (prog[pos] == "~"):
      pos += 1;
      while (prog[pos] in LETEXT):
        buf += prog[pos];
        pos += 1;
      toks.append((T_MCR, buf));
      buf = "";
    elif (prog[pos] in LET):
      while (prog[pos] in LETEXT):
        buf += prog[pos];
        pos += 1;
      if (prog[pos] == ":"):
        toks.append((T_LAB, buf));
        labelscope = buf;
        pos += 1;
      else:
        if (buf in KEY2):
          toks.append((T_INS, buf));
        elif (buf == "bytes"):
          toks.append((T_BYTE, 0));
        elif (buf == "reserve"):
          toks.append((T_MCR, "reserve"));
        elif (buf == "extern"):
          toks.append((T_MCR, "extern"));
        else:
          toks.append((T_0ID, buf));
      buf = "";
    else:
      print(f"\033[31mUnknown\033[0m character {hex(ord(prog[pos]))[2:].upper():0>2}");
      print(f"\033[33m  Note:\033[0m at position {hex(pos)[2:]:0>4}h");
      print(f"\033[33m  Note:\033[0m at position {pos}");
      print(f"\033[33m  Note:\033[0m `{prog[pos]}`");
      exit(1);
  return [], 1;

def FetchLabels(prog: list, disk: bool):
  labs = dict();
  for i in prog:
    if (i[0] == T_LAB):
      labs[i[1]] = i[2]+(0x3000*disk);
  return labs;

def RemEmpty(prog: str):
  return "\n".join([i for i in prog.split("\n") if i]);

# Parser:
def Parse(toks: list, filename: str, expm: int) -> list:
  labels: dict = {};
  ast:    list = [];
  pos:    int  = 0;
  pc:     int  = 0;
  while (toks[pos][0] != T_EOF):
    if (toks[pos][0] == T_INS): # Parse instruction
      if (toks[pos][1] == "mov"): # MOV
        if (toks[pos+2][0] == T_INT): # MOV reg16 imm16
          ast.append([ASTINS, "mov:a", (toks[pos+1][1], toks[pos+2][1]), pc]);
          pc += 3; # 40 00 00
          pos += 3;
        elif (toks[pos+2][0] == T_REG): # MOV reg16 reg16
          ast.append([ASTINS, "mov:r", (toks[pos+1][1], toks[pos+2][1]), pc]);
          pc += 2; # 66 A5 00 (NO)
          pos += 3;
        elif (toks[pos+2][0] == T_0ID): # MOV m16(label)
          ast.append([ASTINS, "mov:l", (toks[pos+1][1], toks[pos+2][1]), pc]);
          pc += 3; # 40 71 05
          pos += 3;
        elif (toks[pos+2][0] == T_IDD): # MOV *m16(label)
          ast.append([ASTINS, "mov:b", (toks[pos+1][1], toks[pos+2][1]), pc]);
          pc += 3;
          pos += 3;
        elif (toks[pos+2][0] == T_DREG): # MOV *reg16 m16(label)
          ast.append([ASTINS, "mov:R", (toks[pos+1][1], toks[pos+2][1]), pc]);
          pc += 2;
          pos += 3;
        else:
          print("Unknown mov operand");
          exit(1);
      elif (toks[pos][1] == "mb"): # MB
        if (toks[pos+2][0] == T_INT): # MB m16 imm8
          ast.append([ASTINS, "mb:a", (toks[pos+1][1], toks[pos+2][1]), pc]);
          pc += 4;
          pos += 3;
        elif (toks[pos+2][0] == T_REG): # MB m16 reg16
          ast.append([ASTINS, "mb:r", (toks[pos+1][1], toks[pos+2][1]), pc]);
          pc += 4;
          pos += 3;
        else:
          print("Unknown mb operand");
          exit(1);
      elif (toks[pos][1] == "mw"): # MW
        if (toks[pos+2][0] == T_INT): # MW m16 imm16
          ast.append([ASTINS, "mw:a", (toks[pos+1][1], toks[pos+2][1]), pc]);
          pc += 5;
          pos += 3;
        elif (toks[pos+2][0] == T_REG): # MW m16 reg16
          ast.append([ASTINS, "mw:r", (toks[pos+1][1], toks[pos+2][1]), pc]);
          pc += 5;
          pos += 3;
        else:
          print("Unknown mb operand");
          exit(1);
      elif (toks[pos][1] == "lda"): # LDA
        if (toks[pos+1][0] == T_INT): # LDA immediate
          ast.append([ASTINS, "lda:a", toks[pos+1][1], pc]);
          pc += 3; # 40 00 00
          pos += 2;
        elif (toks[pos+1][0] == T_REG): # LDA register
          ast.append([ASTINS, "lda:r", toks[pos+1][1], pc]);
          pc += 2; # 66 A5 00
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # LDA address (label)
          ast.append([ASTINS, "lda:l", toks[pos+1][1], pc]);
          pc += 3; # 40 71 05
          pos += 2;
        elif (toks[pos+1][0] == T_IDD): # LDA DRF ADDR16(LABEL)
          ast.append([ASTINS, "lda:b", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_DREG): # LDA *reg16 ADDR16(LABEL)
          ast.append([ASTINS, "lda:R", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        else:
          print("Unknown lda operand");
          exit(1);
      elif (toks[pos][1] == "ldb"): # LDB
        if (toks[pos+1][0] == T_INT): # LDB immediate
          ast.append([ASTINS, "ldb:a", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_REG): # LDB register
          ast.append([ASTINS, "ldb:r", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # LDB address (label)
          ast.append([ASTINS, "ldb:l", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_IDD): # LDB DRF ADDR16(LABEL)
          ast.append([ASTINS, "ldb:b", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_DREG): # LDB *reg16 ADDR16(LABEL)
          ast.append([ASTINS, "ldb:R", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        else:
          print("Unknown ldb operand");
          exit(1);
      elif (toks[pos][1] == "ldc"): # LDC
        if (toks[pos+1][0] == T_INT): # LDC immediate
          ast.append([ASTINS, "ldc:a", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_REG): # LDC register
          ast.append([ASTINS, "ldc:r", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # LDC address (label)
          ast.append([ASTINS, "ldc:l", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_IDD): # LDC DRF ADDR16(LABEL)
          ast.append([ASTINS, "ldc:b", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_DREG): # LDC *reg16 ADDR16(LABEL)
          ast.append([ASTINS, "ldc:R", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        else:
          print("Unknown ldc operand");
          exit(1);
      elif (toks[pos][1] == "ldd"): # LDD
        if (toks[pos+1][0] == T_INT): # LDD immediate
          ast.append([ASTINS, "ldd:a", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_REG): # LDD register
          ast.append([ASTINS, "ldd:r", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # LDD address (label)
          ast.append([ASTINS, "ldd:l", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_IDD): # LDD DRF ADDR16(LABEL)
          ast.append([ASTINS, "ldd:b", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_DREG): # LDD *reg16 ADDR16(LABEL)
          ast.append([ASTINS, "ldd:R", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        else:
          print("Unknown ldd operand");
          exit(1);
      elif (toks[pos][1] == "lds"): # LDS
        if (toks[pos+1][0] == T_INT): # LDS IMM16
          ast.append([ASTINS, "lds:a", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_REG): # LDS REG16
          ast.append([ASTINS, "lds:r", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # LDS ADDR16(LABEL)
          ast.append([ASTINS, "lds:l", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_IDD): # LDS DRF ADDR16(LABEL)
          ast.append([ASTINS, "lds:b", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_DREG): # LDS *reg16 ADDR16(LABEL)
          ast.append([ASTINS, "lds:R", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        else:
          print(f"Unknown lds operand {pos}");
          exit(1);
      elif (toks[pos][1] == "ldg"): # LDG
        if (toks[pos+1][0] == T_INT): # LDG immediate
          ast.append([ASTINS, "ldg:a", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_REG): # LDG register
          ast.append([ASTINS, "ldg:r", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # LDG address (label)
          ast.append([ASTINS, "ldg:l", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_IDD): # LDG DRF ADDR16(LABEL)
          ast.append([ASTINS, "ldg:b", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_DREG): # LDG *reg16 ADDR16(LABEL)
          ast.append([ASTINS, "ldg:R", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        else:
          print("Unknown ldg operand");
          exit(1);
      elif (toks[pos][1] == "str"): # STR
        if (toks[pos+1][0] == T_INT): # STR imm8
          ast.append([ASTINS, "str:8", toks[pos+1][1]%256, pc]);
          pc += 2;
          pos += 2;
        else:
          print("Unknown str operand");
          exit(1);
      elif (toks[pos][1] == "push"): # PUSH
        if (toks[pos+1][0] == T_INT): # PUSH immediate
          ast.append([ASTINS, "push:i", toks[pos+1][1], pc]);
          pc += 4; # 0F 84 00 00
          pos += 2;
        elif (toks[pos+1][0] == T_REG): # PUSH immediate
          ast.append([ASTINS, "push:r", toks[pos+1][1], pc]);
          pc += 3; # 0F 90 04
          pos += 2;
        elif (toks[pos+1][0] == T_DREG): # PUSH derefenced register
          ast.append([ASTINS, "push:R", toks[pos+1][1], pc]);
          pc += 3; # 0F 82 03
          pos += 2;
        else:
          print("No. PUSH");
          exit(1);
      elif (toks[pos][1] == "add"): # ADD
        if ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_INT)): # ADD %R $I
          ast.append([ASTINS, "add:ra", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 4;
          pos += 3;
        elif ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_REG)): # ADD %R %R
          ast.append([ASTINS, "add:c", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 3;
          pos += 3;
        else:
          print("No. ADD");
          exit(1);
      elif (toks[pos][1] == "sub"): # SUB
        if ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_INT)): # SUB %R $I
          ast.append([ASTINS, "sub:ra", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 4;
          pos += 3;
        elif ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_REG)): # SUB %R %R
          ast.append([ASTINS, "sub:c", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 3;
          pos += 3;
        else:
          print("No. SUB");
          exit(1);
      elif (toks[pos][1] == "mul"): # MUL
        if ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_INT)): # MUL %R $I
          ast.append([ASTINS, "mul:ra", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 4;
          pos += 3;
        elif ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_REG)): # MUL %R %R
          ast.append([ASTINS, "mul:c", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 3;
          pos += 3;
        else:
          print("No. SUB");
          exit(1);
      elif (toks[pos][1] == "div"): # SUB
        if ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_INT)): # SUB %R $I
          ast.append([ASTINS, "div:ra", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 4;
          pos += 3;
        elif ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_REG)): # SUB %R %R
          ast.append([ASTINS, "div:c", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 3;
          pos += 3;
        else:
          print("No. DIV");
          exit(1);
      elif (toks[pos][1] == "ldds"): # LDDS
        ast.append([ASTINS, "ldds:0", 0, pc]);
        pc += 2;
        pos += 1;
      elif (toks[pos][1] == "lodsb"): # LODSB
        ast.append([ASTINS, "lodsb:0", 0, pc]);
        pc += 2;
        pos += 1;
      elif (toks[pos][1] == "lodgb"): # LODGB
        ast.append([ASTINS, "lodgb:0", 0, pc]);
        pc += 2;
        pos += 1;
      elif (toks[pos][1] == "ret"): # RET
        ast.append([ASTINS, "ret:0", 0, pc]);
        pc += 1;
        pos += 1;
      elif (toks[pos][1] == "int"): # INT
        if (toks[pos+1][0] == T_INT): # Interrupt (byte)
          ast.append([ASTINS, "int:f", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        else:
          print("No. INT");
          exit(1);
      elif (toks[pos][1] == "inx"): # INX
        if (toks[pos+1][0] == T_REG): # INX REG16
          ast.append([ASTINS, "inx:r", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # INX ADDR16(LABEL)
          ast.append([ASTINS, "inx:b", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        else:
          print("No. INX");
          exit(1);
      elif (toks[pos][1] == "dex"): # DEX
        if (toks[pos+1][0] == T_REG): # DEX REG16
          ast.append([ASTINS, "dex:r", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # DEX ADDR16(LABEL)
          ast.append([ASTINS, "dex:b", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        else:
          print("No. INX");
          exit(1);
      elif (toks[pos][1] == "call"): # CALL
        if (toks[pos+1][0] == T_0ID): # CALL Absolute
          ast.append([ASTINS, "call:b", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_INT): # CALL Absolute(int)
          ast.append([ASTINS, "call:a", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        else:
          print("No. CALL");
          exit(1);
      elif (toks[pos][1] == "jmp"): # JMP
        if (toks[pos+1][0] == T_0ID): # JMP Absolute(label)
          ast.append([ASTINS, "jmp:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        elif (toks[pos+1][0] == T_INT): # JMP Absolute
          ast.append([ASTINS, "jmp:a", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("No. JMP");
          exit(1);
      elif (toks[pos][1] == "jl"): # JL
        if (toks[pos+1][0] == T_0ID): # JL Absolute
          ast.append([ASTINS, "jl:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("No. JL");
          exit(1);
      elif (toks[pos][1] == "jle"): # JLE
        if (toks[pos+1][0] == T_0ID): # JLE Absolute
          ast.append([ASTINS, "jle:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("No. JLE");
          exit(1);
      elif (toks[pos][1] == "jg"): # JG
        if (toks[pos+1][0] == T_0ID): # JG Absolute
          ast.append([ASTINS, "jg:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("No. JG");
          exit(1);
      elif (toks[pos][1] == "jge"): # JGE
        if (toks[pos+1][0] == T_0ID): # JGE Absolute
          ast.append([ASTINS, "jge:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("No. JGE");
          exit(1);
      elif (toks[pos][1] == "jme"): # JME
        if (toks[pos+1][0] == T_0ID): # JME Absolute
          ast.append([ASTINS, "jme:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("No. JME");
          exit(1);
      elif (toks[pos][1] == "jmne"): # JMNE
        if (toks[pos+1][0] == T_0ID): # JMNE Absolute
          ast.append([ASTINS, "jmne:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("No. JMNE");
          exit(1);
      elif (toks[pos][1] == "loop"): # LOOP
        if (toks[pos+1][0] == T_0ID): # LOOP Absolute
          ast.append([ASTINS, "loop:b", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        else:
          print("No. LOOP");
          exit(1);
      elif (toks[pos][1] == "str"): # STR
        if (toks[pos+1][0] == T_INT): # STR imm8
          if (toks[pos+1][1] > 255):
            print("str value more than $FF");
            exit(1);
          ast.append([ASTINS, "str:8", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
      elif (toks[pos][1] == "cmp"): # CMP
        if ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_INT)): # CMP %R $I
          ast.append([ASTINS, "cmp:ra", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 5;
          pos += 3;
        elif ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_REG)): # CMP %R %R
          ast.append([ASTINS, "cmp:c", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 3;
          pos += 3;
        elif ((toks[pos+1][0] == T_DREG) and (toks[pos+2][0] == T_INT)): # CMP *%R $I
          ast.append([ASTINS, "cmp:Ra", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 4;
          pos += 3;
        else:
          print("No. CMP");
          exit(1);
      elif (toks[pos][1] == "nop"): # NOP
        ast.append([ASTINS, "nop:0", 0, pc]);
        pc += 1;
        pos += 1;
      elif (toks[pos][1] == "hlt"): # HLT
        ast.append([ASTINS, "hlt:0", 0, pc]);
        pc += 1;
        pos += 1;
      elif (toks[pos][1] == "re"): # RE
        ast.append([ASTINS, "re:0", 0, pc]);
        pc += 1;
        pos += 1;
      elif (toks[pos][1] == "rne"): # RNE
        ast.append([ASTINS, "rne:0", 0, pc]);
        pc += 1;
        pos += 1;
      elif (toks[pos][1] == "pop"): # POP
        ast.append([ASTINS, "pop:r", toks[pos+1][1], pc]);
        pc += 3;
        pos += 2;
      elif (toks[pos][1] == "cop"): # COP
        ast.append([ASTINS, "cop:r", toks[pos+1][1], pc]);
        pc += 2;
        pos += 2;
      elif (toks[pos][1] == "cpuid"): # CPUID
        ast.append([ASTINS, "cpuid:0", 0, pc]);
        pc += 2;
        pos += 1;
      elif (toks[pos][1] == "storb"): # STORB
        ast.append([ASTINS, "storb:r", toks[pos+1][1], pc]);
        pc += 3;
        pos += 2;
      elif (toks[pos][1] == "stgrb"): # STGRB
        ast.append([ASTINS, "stgrb:r", toks[pos+1][1], pc]);
        pc += 3;
        pos += 2;
      elif (toks[pos][1] == "trap"): # TRAP
        ast.append([ASTINS, "trap:0", 0, pc]);
        pc += 2;
        pos += 1;
      elif (toks[pos][1] == "brk"): # BRK
        ast.append([ASTINS, "brk:0", 0, pc]);
        pc += 1;
        pos += 1;
      else:
        print(f"Wtf is {toks[pos][1]}");
        exit(1);
    elif (toks[pos][0] == T_LAB): # Parse a label
      labels[toks[pos][1]] = pc;
      pos += 1;
    elif (toks[pos][0] == T_BYTE): # Parse raw bytes
      ast.append([ASTBYTES, "__B_raw", [], pc]);
      pos += 1;
      while (toks[pos][0] != T_EOL):
        if (toks[pos][0] == T_INT):
          ast[-1][2].append(toks[pos][1]);
          pc += 1;
        elif (toks[pos][0] == T_STR):
          for i in toks[pos][1]:
            ast[-1][2].append(i);
          pc += len(toks[pos][1]);
        else:
          print(f"Your raw bytes are cooked bro. {HUMAN_TOKS[toks[pos][0]]}");
          exit(1);
        pos += 1;
    elif (toks[pos][0] == T_MCR): # Parse macros
      if (toks[pos][1] == "reserve"):
        if (toks[pos+1][0] != T_INT):
          print(f"\033[31mError\033[0m: expected number after reserve.");
          print(f"\033[96mHint\033[0m: syntax for `reserve` is: reserve 10 bytes");
          exit(1);
        if (toks[pos+2][0] == T_BYTE):
          restype = 1; # bytes
        else:
          print(f"\033[31mError\033[0m: expected bytes after reserve #n.");
          print(f"\033[96mHint\033[0m: syntax for `reserve` is: reserve 10 bytes");
          exit(1);
        ast.append([ASTRES, "__B_reserve", toks[pos+1][1]*restype, pc]);
        pc += toks[pos+1][1]*restype;
        pos += 3;
      elif (toks[pos][1] == "extern"):
        if (toks[pos+1][0] != T_STR):
          print(f"\033[31mError\033[0m: expected filename after extern.");
          print(f"\033[96mHint\033[0m: syntax for `extern` is: extern \"filename\"");
          exit(1);
        with open(toks[pos+1][1], "rb") as extern_file:
          extern_source = extern_file.read()
        ast.append([ASTRES, "__B_extern", extern_source, pc]);
        pc += len(extern_source);
        pos += 2;
    elif (toks[pos][0] == T_EOL): # Parse EOL
      pos += 1;
    else:
      print(f"Wtf is token {toks[pos][0]} at {pos}");
      exit(1);
  ast.append([ASTEOF, 0, 0, pc]);
  if (expm):
    print(f"\033[92m{filename}: exporting {pc} bytes\033[0m");
  else:
    print(f"{filename}: program size: {pc} bytes");
  return ast, labels;

# Compiler:
def CompileGC16X(prog: list, labs: dict):
  code = bytearray();
  pos = 0;
  while (prog[pos][0] != ASTEOF):
    if (prog[pos][0] == ASTINS):
      if (prog[pos][1] == "mov:a"): # MOV reg16 imm16
        code.append(0x40+prog[pos][2][0]);
        code.append(prog[pos][2][1] % 256);
        code.append(prog[pos][2][1] >> 8);
        pos += 1;
      elif (prog[pos][1] == "mov:r"): # MOV reg16 reg16
        code.append(0x77+prog[pos][2][0]);
        code.append(prog[pos][2][1]);
        pos += 1;
      elif (prog[pos][1] == "mov:R"): # MOV reg16 *reg16
        code.append(0x11+prog[pos][2][0]);
        code.append(prog[pos][2][1]);
        pos += 1;
      elif (prog[pos][1] == "mov:l"): # MOV reg16 m16(label)
        code.append(0x40+prog[pos][2][0]);
        val = labs[prog[pos][2][1]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "mov:b"): # MOV reg16 *m16
        code.append(0x53+prog[pos][2][0]);
        val = labs[prog[pos][2][1]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "mb:a"): # MV m16 imm8
        code.append(0xC0);
        code.append(prog[pos][2][0] % 256);
        code.append(prog[pos][2][0] >> 8);
        code.append(prog[pos][2][1] % 256);
        pos += 1;
      elif (prog[pos][1] == "lda:a"): # LDA immediate
        code.append(0x40);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "lda:r"): # LDA register
        code.append(0x77);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "lda:R"): # LDA *reg16
        code.append(0x11);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "lda:l"): # LDA immediate (label)
        code.append(0x40);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "lda:b"): # LDA absolute
        code.append(0x53);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldb:a"): # LDB immediate
        code.append(0x41);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldb:r"): # LDB register
        code.append(0x78);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "ldb:R"): # LDB *reg16
        code.append(0x12);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "ldb:l"): # LDB immediate (label)
        code.append(0x41);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldb:b"): # LDB absolute
        code.append(0x54);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldc:l"): # LDC immediate (label)
        code.append(0x42);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldc:a"): # LDC immediate
        code.append(0x42);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldc:r"): # LDC register
        code.append(0x79);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "ldc:R"): # LDC *reg16
        code.append(0x13);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "ldc:b"): # LDC absolute
        code.append(0x55);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldd:l"): # LDD immediate (label)
        code.append(0x43);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldd:a"): # LDD immediate
        code.append(0x43);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldd:r"): # LDD register
        code.append(0x7A);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "ldd:R"): # LDD *reg16
        code.append(0x14);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "ldd:b"): # LDD absolute
        code.append(0x56);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "lds:a"): # LDS immediate
        code.append(0x44);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "lds:l"): # LDS immediate (label)
        code.append(0x44);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "lds:r"): # LDS register
        code.append(0x7B);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "lds:R"): # LDS *reg16
        code.append(0x15);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "lds:b"): # LDS absolute
        code.append(0x57);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldg:a"): # LDG immediate
        code.append(0x45);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldg:r"): # LDG register
        code.append(0x7C);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "ldg:R"): # LDG *reg16
        code.append(0x16);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "ldg:l"): # LDG immediate (label)
        code.append(0x45);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldg:b"): # LDG absolute
        code.append(0x58);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "push:i"): # PUSH immediate
        code.append(0x0F);
        code.append(0x84);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "cmp:ra"): # CMP REG16 IMM16
        code.append(0x10);
        code.append(0xEE);
        code.append(prog[pos][2][0] % 256);
        code.append(prog[pos][2][1] % 256);
        code.append(prog[pos][2][1] >> 8);
        pos += 1;
      elif (prog[pos][1] == "cmp:Ra"): # CMP *REG16 IMM16
        code.append(0x69);
        code.append(prog[pos][2][0] % 256);
        code.append(prog[pos][2][1] % 256);
        code.append(prog[pos][2][1] >> 8);
        pos += 1;
      elif (prog[pos][1] == "cmp:c"): # CMP REG16 REG16
        code.append(0x10);
        code.append(0xF6); # A B C D S G SP BP
        code.append((prog[pos][2][0]*16)+(prog[pos][2][1]));
        pos += 1;
      elif (prog[pos][1] == "add:c"): # ADD REG16 REG16
        code.append(0x10);
        code.append(0x00); # A B C D S G SP BP
        code.append((prog[pos][2][0]*16)+(prog[pos][2][1]));
        pos += 1;
      elif (prog[pos][1] == "add:ra"): # ADD REG16 IMM16
        code.append(0x10);
        code.append(0x08+prog[pos][2][0]);
        code.append(prog[pos][2][1] % 256);
        code.append(prog[pos][2][1] >> 8);
        pos += 1;
      elif (prog[pos][1] == "mul:c"): # MUL REG16 REG16
        code.append(0x10);
        code.append(0x02); # A B C D S G SP BP
        code.append((prog[pos][2][0]*16)+(prog[pos][2][1]));
        pos += 1;
      elif (prog[pos][1] == "mul:ra"): # MUL REG16 IMM16
        code.append(0x10);
        code.append(0x28+prog[pos][2][0]);
        code.append(prog[pos][2][1] % 256);
        code.append(prog[pos][2][1] >> 8);
        pos += 1;
      elif (prog[pos][1] == "div:c"): # DIV REG16 REG16
        code.append(0x10);
        code.append(0x03); # A B C D S G SP BP
        code.append((prog[pos][2][0]*16)+(prog[pos][2][1]));
        pos += 1;
      elif (prog[pos][1] == "div:ra"): # DIV REG16 IMM16
        code.append(0x10);
        code.append(0x38+prog[pos][2][0]);
        code.append(prog[pos][2][1] % 256);
        code.append(prog[pos][2][1] >> 8);
        pos += 1;
      elif (prog[pos][1] == "sub:c"): # SUB REG16 REG16
        code.append(0x10);
        code.append(0x01); # A B C D S G SP BP
        code.append((prog[pos][2][0]*16)+(prog[pos][2][1]));
        pos += 1;
      elif (prog[pos][1] == "sub:ra"): # SUB REG16 IMM16
        code.append(0x10);
        code.append(0x18+prog[pos][2][0]);
        code.append(prog[pos][2][1] % 256);
        code.append(prog[pos][2][1] >> 8);
        pos += 1;
      elif (prog[pos][1] == "push:r"): # PUSH register
        code.append(0x0F);
        code.append(0x90);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "push:R"): # PUSH derefenced register
        code.append(0x0F);
        code.append(0x82);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "lodsb:0"): # LODSB
        code.append(0x10);
        code.append(0x87);
        pos += 1;
      elif (prog[pos][1] == "lodgb:0"): # LODGB
        code.append(0x10);
        code.append(0x89);
        pos += 1;
      elif (prog[pos][1] == "ldds:0"): # LDDS
        code.append(0x10);
        code.append(0x8B);
        pos += 1;
      elif (prog[pos][1] == "ret:0"): # RET
        code.append(0x33);
        pos += 1;
      elif (prog[pos][1] == "cpuid:0"): # CPUID
        code.append(0x0F);
        code.append(0xE9);
        pos += 1;
      elif (prog[pos][1] == "int:f"): # INT IMM8
        code.append(0x0F);
        code.append(0xC2);
        code.append(prog[pos][2] % 256);
        pos += 1;
      elif (prog[pos][1] == "inx:r"): # INX REG16
        code.append(0x10);
        code.append(0xC0+prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "dex:r"): # DEX REG16
        code.append(0x10);
        code.append(0xD0+prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "inx:b"): # INX ADDR16
        code.append(0xB0);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "dex:b"): # DEX ADDR16
        code.append(0x90);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "str:8"): # STR imm8
        code.append(0xB1);
        code.append(prog[pos][2] % 256);
        pos += 1;
      elif (prog[pos][1] == "call:b"): # CALL ADDR16
        code.append(0xC7);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "call:a"): # CALL ADDR16(INT)
        code.append(0xC7);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "jmp:b"): # JMP ADDR16
        code.append(0x0F);
        code.append(0x30);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "jmp:a"): # JMP ADDR16(INT)
        code.append(0x0F);
        code.append(0x30);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "jl:b"): # JL ADDR16
        code.append(0x0F);
        code.append(0xBB);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "jle:b"): # JLE ADDR16
        code.append(0x0F);
        code.append(0xBC);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "jg:b"): # JG ADDR16
        code.append(0x0F);
        code.append(0xCB);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "jge:b"): # JGE ADDR16
        code.append(0x0F);
        code.append(0xCC);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "jme:b"): # JME ADDR16
        code.append(0x0F);
        code.append(0x29);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "jmne:b"): # JMNE ADDR16
        code.append(0x0F);
        code.append(0x2A);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "loop:b"): # LOOP ADDR16
        code.append(0xB8);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "trap:0"): # TRAP
        code.append(0x0F);
        code.append(0x9D);
        pos += 1;
      elif (prog[pos][1] == "brk:0"): # BRK
        code.append(0x00);
        pos += 1;
      elif (prog[pos][1] == "nop:0"): # NOP
        code.append(0xEA);
        pos += 1;
      elif (prog[pos][1] == "hlt:0"): # HLT
        code.append(0x51);
        pos += 1;
      elif (prog[pos][1] == "re:0"): # RE
        code.append(0x2B);
        pos += 1;
      elif (prog[pos][1] == "rne:0"): # RNE
        code.append(0x3B);
        pos += 1;
      elif (prog[pos][1] == "pop:r"): # POP
        code.append(0x0F);
        code.append(0x80);
        code.append(prog[pos][2] % 256);
        pos += 1;
      elif (prog[pos][1] == "cop:r"): # COP
        code.append(0xD7);
        code.append(prog[pos][2] % 256);
        pos += 1;
      elif (prog[pos][1] == "storb:r"): # STORB
        code.append(0x10);
        code.append(0x80);
        code.append(prog[pos][2] % 256);
        pos += 1;
      elif (prog[pos][1] == "stgrb:r"): # STGRB
        code.append(0x10);
        code.append(0x81);
        code.append(prog[pos][2] % 256);
        pos += 1;
      else:
        print(f"\033[31mUnknown\033[0m instruction {prog[pos][1]}");
        exit(1);
    elif (prog[pos][0] == ASTBYTES):
      code.extend(prog[pos][2]);
      pos += 1;
    elif (prog[pos][0] == ASTRES):
      code.extend(bytes(prog[pos][2]));
      pos += 1;
    else:
      print(f"\033[31mUnknown\033[0m token {prog[pos]}");
      print(f"  At position {pos}");
      exit(1);

  return code, 0;

def main(argc: int, argv: list) -> int:
  diskmode = False;
  exportmode = False;
  if (argc == 1):
    print("No arguments given");
    return 1;
  elif (argc == 2):
    print("No binary filename given");
    return 1;
  argp: int = 1;
  imp_files = [];
  while (argp < argc):
    match (argv[argp]):
      case "-export":
        exportmode = 1;
        argp += 1;
      case "-import":
        imp_files.append(argv[argp+1]);
        argp += 2;
      case "-d":
        diskmode = True;
        argp += 1;
      case _:
        progname = argv[argp];
        outname = argv[argp+1];
        break;

  if (argc == 3):
    progname = argv[1];
    outname = argv[2];
  # elif (argc == 4):
  #   print(f"\033[31mUnknown\033[0m argument `{argv[1]}`");
  #   return 1;
  #   progname = argv[2];
  #   outname = argv[3];

  with open(progname, "r") as fl:
    src = fl.read();
  src = RemEmpty(src)+"\0";
  tokens, exitcode = Lex(src, progname);
  PrintTokens(tokens);
  if (type(tokens[1]) is int):
    print("Fatal error. Can't compile");
    exit(tokens);
  ast, labs = Parse(tokens, progname, exportmode);
  if (diskmode):
    labs = OffsetLabs(labs, 0x3000);
  if (exportmode):
    ExportLabs(progname, labs, outname);
    exit(1);
  for imp_file in imp_files:
    labs = ImportLabs(progname, labs, imp_file);
  c, exitcode = CompileGC16X(ast, labs);
  with open(outname, "wb") as fl:
    fl.write(c);

  return 0;

sys.exit(main(len(sys.argv), sys.argv));
