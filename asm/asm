#!/usr/bin/python3

import sys;
import time;

T_INS   = 0x00;
T_INT   = 0x01;
T_LAB   = 0x02;
T_REG   = 0x03;
T_0ID   = 0x04;
T_ADDR  = 0x05;
T_BYTE  = 0x06;
T_STR   = 0x07;
T_IDD   = 0x08;
T_MCR   = 0x09;
T_EOL   = 0x0A;
T_EOF   = 0x0B;

ASTINS   = 0x00;
ASTBYTES = 0x01;
ASTRES   = 0x02;
ASTBRKH  = 0x03;
ASTEOF   = 0x04;

HUMAN_TOKS = ["INST", "INT", "LABEL", "REG", "NAME", "ADDRESS", "BYTES", "STRING", "DRF-NAME", "MCR", "EOL", "EOF"];
HUMAN_AST  = ["INST", "BYTES", "RESERVE", "BRK-HANDLER", "EOF"];

LET    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
DIG    = "0123456789";
WHI    = " \r\0\t";
DIGEXT = "0123456789ABCDEF";
KEY2   = [
  "lda", "ldb", "ldc", "ldd", "lds", "ldg", "push", "int", "lodsb", "lodgb", "cmp", "inx", "dex", "jme", "jmne", "ret", "jmp",
  "call", "nop", "loop", "cop", "storb", "stgrb", "cpuid", "hlt", "pop", "add", "sub", "div", "brk", "ldds", "re", "rne", "mul"
];
KEYR   = ["a", "b", "c", "d", "s", "g", "sp", "bp"];
regids = ["a", "b", "c", "d", "s", "g"];

def PrintTokens(toks: list):
  for i,j in enumerate(toks):
    if (len(j) == 2):
      print(f"{i}: {HUMAN_TOKS[j[0]]} {j[1]}");
    elif (len(j) == 1):
      print(f"{i}: {HUMAN_TOKS[j[0]]}");

def PrintAst(toks: list):
  for i in toks:
    print(f"${hex(i[3])[2:].upper():0>4}: {HUMAN_AST[i[0]]} {i[1]} {i[2]}");

def PrintLabs(labs: dict):
  print("\nLabel symbols:");
  for i in labs:
    print(f"{i}: ${hex(labs[i])[2:].upper():0>4}");

# Lexer:
def Lex(prog: str):
  prog += "\n\0";
  toks = [];
  pos = 0;
  # cpos = 0;
  proglen = len(prog);
  # basemode = 10;
  buf = "";
  while (True):
    if (prog[pos] == "\0"):
      toks.append((T_EOL,));
      toks.append((T_EOF,));
      return toks, 0;
    elif (prog[pos] == ";"):
      pos += 1;
      while (prog[pos] != "\n"):
        pos += 1;
    elif (prog[pos] in WHI):
      pos += 1;
    elif (prog[pos] == "\n"):
      if ((toks) and (toks[-1][0] != T_EOL)):
        toks.append((T_EOL,));
      pos += 1;
    elif (prog[pos] in "."):
      pos += 1;
      toks.append((T_REG, KEYR.index(prog[pos])));
      toks.append((T_REG, KEYR.index(prog[pos+1])));
      pos += 2;
      cpos += 1;
    elif (prog[pos] in "%"):
      pos += 1;
      while (prog[pos] in LET):
        buf += prog[pos];
        pos += 1;
      pos += 1;
      if (buf in KEYR):
        toks.append((T_REG, KEYR.index(buf)));
        # cpos += 1;
      else:
        print(f"\033[31mUnknown\033[0m register {buf}");
        print(f"\033[33m  Note:\033[0m at position {hex(pos)[2:]:0>4}h");
        print(f"\033[33m  Note:\033[0m at position {pos}");
        return 1;
      buf = "";
    elif (prog[pos] in "#"):
      pos += 1;
      while (prog[pos] in DIG):
        buf += prog[pos];
        pos += 1;
      pos += 1;
      toks.append((T_INT, int(buf, base=10)));
      buf = "";
    elif (prog[pos] == "\""):
      pos += 1;
      while (prog[pos] != "\""):
        if (prog[pos] == "$"):
          buf += "\n";
        elif ((prog[pos] == "\\") and (prog[pos+1] == "\"")):
          buf += "\"";
          pos += 2;
        elif (prog[pos] == "^"):
          if (ord(prog[pos+1]) in range(64, 97)):
            buf += chr(ord(prog[pos+1])-64);
          elif (prog[pos+1] in "^$"):
            buf += prog[pos+1];
          pos += 1;
        else:
          buf += prog[pos];
        pos += 1;
      pos += 1;
      toks.append((T_STR, buf));
      buf = "";
    elif (prog[pos] == "'"):
      pos += 1;
      if (prog[pos] == "$"):
        buf = 10;
      elif ((prog[pos] == "\\") and (prog[pos+1] == "\"")):
        buf = 34;
        pos += 2;
      elif (prog[pos] == "^"):
        if (ord(prog[pos+1]) in range(64, 97)):
          buf = ord(prog[pos+1])-64;
        elif (prog[pos+1] in "^$"):
          buf = ord(prog[pos+1]);
        pos += 1;
      else:
        buf = ord(prog[pos]);
      pos += 1;
      if (prog[pos] != "'"):
        print("\033[31mError\033[0m: unterminated character literal");
        print("\033[96mHint\033[0m: the syntax is '([a-zA-Z$])|(\\^[@-`$])'");
        exit(1);
      pos += 1;
      toks.append((T_INT, buf));
    elif (prog[pos] == "^"):
      pos += 1;
      while (prog[pos] in DIGEXT):
        buf += prog[pos];
        pos += 1;
      pos += 1;
      toks.append((T_INT, int(buf, base=16)));
      buf = "";
      # cpos += 1;
    elif (prog[pos] == "$"):
      pos += 1;
      while (prog[pos] in DIGEXT):
        buf += prog[pos];
        pos += 1;
      pos += 1;
      toks.append((T_INT, int(buf, base=16)));
      buf = "";
      # cpos += 1+bytesmode;
      # bytesmode = 1;
    elif (prog[pos] == "*"):
      pos += 1;
      while (prog[pos] in LET+DIG+"-"):
        buf += prog[pos];
        pos += 1;
      toks.append((T_IDD, buf));
      buf = "";
    elif (prog[pos] == "~"):
      pos += 1;
      while (prog[pos] in LET+DIG+"-"):
        buf += prog[pos];
        pos += 1;
      toks.append((T_MCR, buf));
      buf = "";
    elif (prog[pos] in LET):
      while (prog[pos] in LET+DIG+"-"):
        buf += prog[pos];
        pos += 1;
      if (prog[pos] == ":"):
        toks.append((T_LAB, buf));
        pos += 1;
      else:
        if (buf in KEY2):
          toks.append((T_INS, buf));
        elif (buf == "bytes"):
          toks.append((T_BYTE, 0));
        elif (buf == "reserve"):
          toks.append((T_MCR, "reserve"));
        else:
          toks.append((T_0ID, buf));
      buf = "";
    else:
      print(f"\033[31mUnknown\033[0m character {hex(ord(prog[pos]))[2:].upper():0>2}");
      print(f"\033[33m  Note:\033[0m at position {hex(pos)[2:]:0>4}h");
      print(f"\033[33m  Note:\033[0m at position {pos}");
      print(f"\033[33m  Note:\033[0m `{prog[pos]}`");
      return [], 1;
  return [], 1;

def FetchLabels(prog: list, disk: bool):
  labs = dict();
  for i in prog:
    if (i[0] == T_LAB):
      labs[i[1]] = i[2]+(0x91EE*disk);
  return labs;

def RemEmpty(prog: str):
  return "\n".join([i for i in prog.split("\n") if i]);

# Parser:
def Parse(toks: list) -> list:
  labels: dict = {};
  ast:    list = [];
  pos:    int  = 0;
  pc:     int  = 0;
  while (toks[pos][0] != T_EOF):
    if (toks[pos][0] == T_INS): # Parse instruction
      if (toks[pos][1] == "lda"): # LDA
        if (toks[pos+1][0] == T_INT): # LDA immediate
          ast.append([ASTINS, "lda:a", toks[pos+1][1], pc]);
          pc += 4; # 66 05 00 00
          pos += 2;
        elif (toks[pos+1][0] == T_REG): # LDA register
          ast.append([ASTINS, "lda:r", toks[pos+1][1], pc]);
          pc += 3; # 66 A5 00
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # LDA address (label)
          ast.append([ASTINS, "lda:l", toks[pos+1][1], pc]);
          pc += 4; # 66 05 71 05
          pos += 2;
        elif (toks[pos+1][0] == T_IDD): # LDA DRF ADDR16(LABEL)
          ast.append([ASTINS, "lda:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("Unknown lda operand");
          exit(1);
      elif (toks[pos][1] == "ldb"): # LDB
        if (toks[pos+1][0] == T_INT): # LDB immediate
          ast.append([ASTINS, "ldb:a", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        elif (toks[pos+1][0] == T_REG): # LDB register
          ast.append([ASTINS, "ldb:r", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # LDB address (label)
          ast.append([ASTINS, "ldb:l", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        elif (toks[pos+1][0] == T_IDD): # LDB DRF ADDR16(LABEL)
          ast.append([ASTINS, "ldb:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("Unknown ldb operand");
          exit(1);
      elif (toks[pos][1] == "ldc"): # LDC
        if (toks[pos+1][0] == T_INT): # LDC immediate
          ast.append([ASTINS, "ldc:a", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        elif (toks[pos+1][0] == T_REG): # LDC register
          ast.append([ASTINS, "ldc:r", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # LDC address (label)
          ast.append([ASTINS, "ldc:l", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        elif (toks[pos+1][0] == T_IDD): # LDC DRF ADDR16(LABEL)
          ast.append([ASTINS, "ldc:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("Unknown ldc operand");
          exit(1);
      elif (toks[pos][1] == "ldd"): # LDD
        if (toks[pos+1][0] == T_INT): # LDD immediate
          ast.append([ASTINS, "ldd:a", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        elif (toks[pos+1][0] == T_REG): # LDD register
          ast.append([ASTINS, "ldd:r", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # LDD address (label)
          ast.append([ASTINS, "ldd:l", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        elif (toks[pos+1][0] == T_IDD): # LDD DRF ADDR16(LABEL)
          ast.append([ASTINS, "ldd:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("Unknown ldd operand");
          exit(1);
      elif (toks[pos][1] == "lds"): # LDS
        if (toks[pos+1][0] == T_INT): # LDS IMM16
          ast.append([ASTINS, "lds:a", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        elif (toks[pos+1][0] == T_REG): # LDS REG16
          ast.append([ASTINS, "lds:r", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # LDS ADDR16(LABEL)
          ast.append([ASTINS, "lds:l", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        elif (toks[pos+1][0] == T_IDD): # LDS DRF ADDR16(LABEL)
          ast.append([ASTINS, "lds:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print(f"Unknown lds operand {pos}");
          exit(1);
      elif (toks[pos][1] == "ldg"): # LDG
        if (toks[pos+1][0] == T_INT): # LDG immediate
          ast.append([ASTINS, "ldg:a", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        elif (toks[pos+1][0] == T_REG): # LDG register
          ast.append([ASTINS, "ldg:r", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # LDG address (label)
          ast.append([ASTINS, "ldg:l", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        elif (toks[pos+1][0] == T_IDD): # LDG DRF ADDR16(LABEL)
          ast.append([ASTINS, "ldg:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("Unknown ldg operand");
          exit(1);
      elif (toks[pos][1] == "push"): # PUSH
        if (toks[pos+1][0] == T_INT): # PUSH immediate
          ast.append([ASTINS, "push:i", toks[pos+1][1], pc]);
          pc += 4; # 0F 84 00 00
          pos += 2;
        elif (toks[pos+1][0] == T_REG): # PUSH immediate
          ast.append([ASTINS, "push:r", toks[pos+1][1], pc]);
          pc += 3; # 0F 90 04
          pos += 2;
        else:
          print("No. PUSH");
          exit(1);
      elif (toks[pos][1] == "add"): # ADD
        if ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_INT)): # ADD %R $I
          ast.append([ASTINS, "add:ra", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 4;
          pos += 3;
        elif ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_REG)): # ADD %R %R
          ast.append([ASTINS, "add:c", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 3;
          pos += 3;
        else:
          print("No. ADD");
          exit(1);
      elif (toks[pos][1] == "sub"): # SUB
        if ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_INT)): # SUB %R $I
          ast.append([ASTINS, "sub:ra", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 4;
          pos += 3;
        elif ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_REG)): # SUB %R %R
          ast.append([ASTINS, "sub:c", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 3;
          pos += 3;
        else:
          print("No. SUB");
          exit(1);
      elif (toks[pos][1] == "mul"): # MUL
        if ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_INT)): # MUL %R $I
          ast.append([ASTINS, "mul:ra", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 4;
          pos += 3;
        elif ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_REG)): # MUL %R %R
          ast.append([ASTINS, "mul:c", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 3;
          pos += 3;
        else:
          print("No. SUB");
          exit(1);
      elif (toks[pos][1] == "div"): # SUB
        if ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_INT)): # SUB %R $I
          ast.append([ASTINS, "div:ra", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 4;
          pos += 3;
        elif ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_REG)): # SUB %R %R
          ast.append([ASTINS, "div:c", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 3;
          pos += 3;
        else:
          print("No. DIV");
          exit(1);
      elif (toks[pos][1] == "ldds"): # LDDS
        ast.append([ASTINS, "ldds:0", 0, pc]);
        pc += 2;
        pos += 1;
      elif (toks[pos][1] == "lodsb"): # LODSB
        ast.append([ASTINS, "lodsb:0", 0, pc]);
        pc += 2;
        pos += 1;
      elif (toks[pos][1] == "lodgb"): # LODGB
        ast.append([ASTINS, "lodgb:0", 0, pc]);
        pc += 2;
        pos += 1;
      elif (toks[pos][1] == "ret"): # RET
        ast.append([ASTINS, "ret:0", 0, pc]);
        pc += 1;
        pos += 1;
      elif (toks[pos][1] == "int"): # INT
        if (toks[pos+1][0] == T_INT): # Interrupt (byte)
          ast.append([ASTINS, "int:f", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        else:
          print("No. INT");
          exit(1);
      elif (toks[pos][1] == "inx"): # INX
        if (toks[pos+1][0] == T_REG): # INX REG16
          ast.append([ASTINS, "inx:r", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # INX ADDR16(LABEL)
          ast.append([ASTINS, "inx:b", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        else:
          print("No. INX");
          exit(1);
      elif (toks[pos][1] == "dex"): # DEX
        if (toks[pos+1][0] == T_REG): # DEX REG16
          ast.append([ASTINS, "dex:r", toks[pos+1][1], pc]);
          pc += 2;
          pos += 2;
        elif (toks[pos+1][0] == T_0ID): # DEX ADDR16(LABEL)
          ast.append([ASTINS, "dex:b", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        else:
          print("No. INX");
          exit(1);
      elif (toks[pos][1] == "call"): # CALL
        if (toks[pos+1][0] == T_0ID): # CALL Absolute
          ast.append([ASTINS, "call:b", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        else:
          print("No. CALL");
          exit(1);
      elif (toks[pos][1] == "jmp"): # JMP
        if (toks[pos+1][0] == T_0ID): # JMP Absolute
          ast.append([ASTINS, "jmp:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("No. JMP");
          exit(1);
      elif (toks[pos][1] == "jme"): # JME
        if (toks[pos+1][0] == T_0ID): # JME Absolute
          ast.append([ASTINS, "jme:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("No. JME");
          exit(1);
      elif (toks[pos][1] == "jmne"): # JMNE
        if (toks[pos+1][0] == T_0ID): # JMNE Absolute
          ast.append([ASTINS, "jmne:b", toks[pos+1][1], pc]);
          pc += 4;
          pos += 2;
        else:
          print("No. JMNE");
          exit(1);
      elif (toks[pos][1] == "loop"): # LOOP
        if (toks[pos+1][0] == T_0ID): # LOOP Absolute
          ast.append([ASTINS, "loop:b", toks[pos+1][1], pc]);
          pc += 3;
          pos += 2;
        else:
          print("No. LOOP");
          exit(1);
      elif (toks[pos][1] == "cmp"): # CMP
        if ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_INT)): # CMP %R $I
          ast.append([ASTINS, "cmp:ra", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 5;
          pos += 3;
        elif ((toks[pos+1][0] == T_REG) and (toks[pos+2][0] == T_REG)): # CMP %R %R
          ast.append([ASTINS, "cmp:c", [toks[pos+1][1], toks[pos+2][1]], pc]);
          pc += 3;
          pos += 3;
        else:
          print("No. CMP");
          exit(1);
      elif (toks[pos][1] == "nop"): # NOP
        ast.append([ASTINS, "nop:0", 0, pc]);
        pc += 1;
        pos += 1;
      elif (toks[pos][1] == "hlt"): # HLT
        ast.append([ASTINS, "hlt:0", 0, pc]);
        pc += 1;
        pos += 1;
      elif (toks[pos][1] == "re"): # RE
        ast.append([ASTINS, "re:0", 0, pc]);
        pc += 1;
        pos += 1;
      elif (toks[pos][1] == "rne"): # RNE
        ast.append([ASTINS, "rne:0", 0, pc]);
        pc += 1;
        pos += 1;
      elif (toks[pos][1] == "pop"): # POP
        ast.append([ASTINS, "pop:r", toks[pos+1][1], pc]);
        pc += 3;
        pos += 2;
      elif (toks[pos][1] == "cop"): # COP
        ast.append([ASTINS, "cop:r", toks[pos+1][1], pc]);
        pc += 2;
        pos += 2;
      elif (toks[pos][1] == "cpuid"): # CPUID
        ast.append([ASTINS, "cpuid:0", 0, pc]);
        pc += 2;
        pos += 1;
      elif (toks[pos][1] == "storb"): # STORB
        ast.append([ASTINS, "storb:r", toks[pos+1][1], pc]);
        pc += 3;
        pos += 2;
      elif (toks[pos][1] == "stgrb"): # STGRB
        ast.append([ASTINS, "stgrb:r", toks[pos+1][1], pc]);
        pc += 3;
        pos += 2;
      elif (toks[pos][1] == "brk"): # BRK
        ast.append([ASTINS, "brk:0", 0, pc]);
        pc += 1;
        pos += 1;
      else:
        print(f"Wtf is {toks[pos][1]}");
        exit(1);
    elif (toks[pos][0] == T_LAB): # Parse a label
      labels[toks[pos][1]] = pc;
      pos += 1;
    elif (toks[pos][0] == T_BYTE): # Parse raw bytes
      ast.append([ASTBYTES, "__B_raw", [], pc]);
      pos += 1;
      while (toks[pos][0] != T_EOL):
        if (toks[pos][0] == T_INT):
          ast[-1][2].append(toks[pos][1]);
          pc += 1;
        elif (toks[pos][0] == T_STR):
          for i in toks[pos][1]:
            ast[-1][2].append(ord(i));
          pc += len(toks[pos][1]);
        else:
          print("Your raw bytes are cooked bro.");
          exit(1);
        pos += 1;
    elif (toks[pos][0] == T_MCR): # Parse macros
      if (toks[pos][1] == "reserve"):
        if (toks[pos+1][0] != T_INT):
          print(f"\033[31mError\033[0m: expected number after reserve.");
          print(f"\033[96mHint\033[0m: syntax for `reserve` is: reserve #10 bytes");
          exit(1);
        if (toks[pos+2][0] == T_BYTE):
          restype = 1; # bytes
        else:
          print(f"\033[31mError\033[0m: expected bytes after reserve #n.");
          print(f"\033[96mHint\033[0m: syntax for `reserve` is: reserve #10 bytes");
          exit(1);
        ast.append([ASTRES, "__B_reserve", toks[pos+1][1]*restype, pc]);
        pc += toks[pos+1][1]*restype;
        pos += 3;
    elif (toks[pos][0] == T_EOL): # Parse EOL
      pos += 1;
    else:
      print(f"Wtf is token {toks[pos][0]} at {pos}");
      exit(1);
  ast.append([ASTEOF, 0, 0, pc]);
  print(f"program size: {ast[-1][3]} bytes");
  return ast, labels;

# Compiler:
def CompileGC16X(prog: list, labs: dict):
  code = bytearray();
  pos = 0;
  while (prog[pos][0] != ASTEOF):
    if (prog[pos][0] == ASTINS):
      if (prog[pos][1] == "lda:a"): # LDA immediate
        code.append(0x66);
        code.append(0x05);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "lda:r"): # LDA register
        code.append(0x66);
        code.append(0xA5);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "lda:l"): # LDA immediate (label)
        code.append(0x66);
        code.append(0x05);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "lda:b"): # LDA absolute
        code.append(0x66);
        code.append(0x55);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldb:a"): # LDB immediate
        code.append(0x66);
        code.append(0x06);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldb:r"): # LDB register
        code.append(0x66);
        code.append(0xA6);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "ldb:l"): # LDB immediate (label)
        code.append(0x66);
        code.append(0x06);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldb:b"): # LDB absolute
        code.append(0x66);
        code.append(0x56);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldc:l"): # LDC immediate (label)
        code.append(0x66);
        code.append(0x07);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldc:a"): # LDC immediate
        code.append(0x66);
        code.append(0x07);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldc:r"): # LDC register
        code.append(0x66);
        code.append(0xA7);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "ldc:b"): # LDC absolute
        code.append(0x66);
        code.append(0x57);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldd:l"): # LDC immediate (label)
        code.append(0x66);
        code.append(0x07);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldd:a"): # LDD immediate
        code.append(0x66);
        code.append(0x08);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldd:r"): # LDD register
        code.append(0x66);
        code.append(0xA8);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "ldd:b"): # LDD absolute
        code.append(0x66);
        code.append(0x58);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "lds:a"): # LDS immediate
        code.append(0x66);
        code.append(0x09);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "lds:l"): # LDS immediate (label)
        code.append(0x66);
        code.append(0x09);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "lds:r"): # LDS register
        code.append(0x66);
        code.append(0xA9);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "lds:b"): # LDS absolute
        code.append(0x66);
        code.append(0x59);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldg:a"): # LDG immediate
        code.append(0x66);
        code.append(0x0A);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldg:r"): # LDG register
        code.append(0x66);
        code.append(0xAA);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "ldg:l"): # LDG immediate (label)
        code.append(0x66);
        code.append(0x0A);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "ldg:b"): # LDG absolute
        code.append(0x66);
        code.append(0x5A);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "push:i"): # PUSH immediate
        code.append(0x0F);
        code.append(0x84);
        code.append(prog[pos][2] % 256);
        code.append(prog[pos][2] >> 8);
        pos += 1;
      elif (prog[pos][1] == "cmp:ra"): # CMP REG16 IMM16
        code.append(0x10);
        code.append(0xEE);
        code.append(prog[pos][2][0] % 256);
        code.append(prog[pos][2][1] % 256);
        code.append(prog[pos][2][1] >> 8);
        pos += 1;
      elif (prog[pos][1] == "cmp:c"): # CMP REG16 REG16
        code.append(0x10);
        code.append(0xF6); # A B C D S G SP BP
        code.append((prog[pos][2][0]*8)+(prog[pos][2][1]));
        pos += 1;
      elif (prog[pos][1] == "add:c"): # ADD REG16 REG16
        code.append(0x10);
        code.append(0x00); # A B C D S G SP BP
        code.append((prog[pos][2][0]*8)+(prog[pos][2][1]));
        pos += 1;
      elif (prog[pos][1] == "add:ra"): # ADD REG16 IMM16
        code.append(0x10);
        code.append(0x08+prog[pos][2][0]);
        code.append(prog[pos][2][1] % 256);
        code.append(prog[pos][2][1] >> 8);
        pos += 1;
      elif (prog[pos][1] == "mul:c"): # MUL REG16 REG16
        code.append(0x10);
        code.append(0x02); # A B C D S G SP BP
        code.append((prog[pos][2][0]*8)+(prog[pos][2][1]));
        pos += 1;
      elif (prog[pos][1] == "mul:ra"): # MUL REG16 IMM16
        code.append(0x10);
        code.append(0x28+prog[pos][2][0]);
        code.append(prog[pos][2][1] % 256);
        code.append(prog[pos][2][1] >> 8);
        pos += 1;
      elif (prog[pos][1] == "div:c"): # DIV REG16 REG16
        code.append(0x10);
        code.append(0x03); # A B C D S G SP BP
        code.append((prog[pos][2][0]*8)+(prog[pos][2][1]));
        pos += 1;
      elif (prog[pos][1] == "div:ra"): # DIV REG16 IMM16
        code.append(0x10);
        code.append(0x38+prog[pos][2][0]);
        code.append(prog[pos][2][1] % 256);
        code.append(prog[pos][2][1] >> 8);
        pos += 1;
      elif (prog[pos][1] == "sub:c"): # SUB REG16 REG16
        code.append(0x10);
        code.append(0x01); # A B C D S G SP BP
        code.append((prog[pos][2][0]*8)+(prog[pos][2][1]));
        pos += 1;
      elif (prog[pos][1] == "sub:ra"): # SUB REG16 IMM16
        code.append(0x10);
        code.append(0x18+prog[pos][2][0]);
        code.append(prog[pos][2][1] % 256);
        code.append(prog[pos][2][1] >> 8);
        pos += 1;
      elif (prog[pos][1] == "push:r"): # PUSH register
        code.append(0x0F);
        code.append(0x90);
        code.append(prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "lodsb:0"): # LODSB
        code.append(0x10);
        code.append(0x87);
        pos += 1;
      elif (prog[pos][1] == "lodgb:0"): # LODGB
        code.append(0x10);
        code.append(0x89);
        pos += 1;
      elif (prog[pos][1] == "ldds:0"): # LDDS
        code.append(0x10);
        code.append(0x8B);
        pos += 1;
      elif (prog[pos][1] == "ret:0"): # RET
        code.append(0x33);
        pos += 1;
      elif (prog[pos][1] == "cpuid:0"): # CPUID
        code.append(0x0F);
        code.append(0xE9);
        pos += 1;
      elif (prog[pos][1] == "int:f"): # INT IMM8
        code.append(0x0F);
        code.append(0xC2);
        code.append(prog[pos][2] % 256);
        pos += 1;
      elif (prog[pos][1] == "inx:r"): # INX REG16
        code.append(0x10);
        code.append(0xC0+prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "dex:r"): # DEX REG16
        code.append(0x10);
        code.append(0xD0+prog[pos][2]);
        pos += 1;
      elif (prog[pos][1] == "inx:b"): # INX ADDR16
        code.append(0xB0);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "dex:b"): # DEX ADDR16
        code.append(0x90);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "call:b"): # CALL ADDR16
        code.append(0xC7);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "jmp:b"): # JMP ADDR16
        code.append(0x0F);
        code.append(0x30);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "jme:b"): # JME ADDR16
        code.append(0x0F);
        code.append(0x29);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "jmne:b"): # JMNE ADDR16
        code.append(0x0F);
        code.append(0x2A);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "loop:b"): # LOOP ADDR16
        code.append(0xB8);
        val = labs[prog[pos][2]];
        code.append(val % 256);
        code.append(val >> 8);
        pos += 1;
      elif (prog[pos][1] == "brk:0"): # BRK
        code.append(0x00);
        pos += 1;
      elif (prog[pos][1] == "nop:0"): # NOP
        code.append(0xEA);
        pos += 1;
      elif (prog[pos][1] == "hlt:0"): # HLT
        code.append(0x51);
        pos += 1;
      elif (prog[pos][1] == "re:0"): # RE
        code.append(0x2B);
        pos += 1;
      elif (prog[pos][1] == "rne:0"): # RNE
        code.append(0x3B);
        pos += 1;
      elif (prog[pos][1] == "pop:r"): # POP
        code.append(0x0F);
        code.append(0x80);
        code.append(prog[pos][2] % 256);
        pos += 1;
      elif (prog[pos][1] == "cop:r"): # COP
        code.append(0xD7);
        code.append(prog[pos][2] % 256);
        pos += 1;
      elif (prog[pos][1] == "storb:r"): # STORB
        code.append(0x10);
        code.append(0x80);
        code.append(prog[pos][2] % 256);
        pos += 1;
      elif (prog[pos][1] == "stgrb:r"): # STGRB
        code.append(0x10);
        code.append(0x81);
        code.append(prog[pos][2] % 256);
        pos += 1;
      else:
        print(f"\033[31mUnknown\033[0m instruction {prog[pos][1]}");
        exit(1);
    elif (prog[pos][0] == ASTBYTES):
      code.extend(prog[pos][2]);
      pos += 1;
    elif (prog[pos][0] == ASTRES):
      code.extend(bytes(prog[pos][2]));
      pos += 1;
    else:
      print(f"\033[31mUnknown\033[0m token {prog[pos]}");
      print(f"  At position {pos}");
      exit(1);

  return code, 0;

def main(argc: int, argv: list) -> int:
  diskmode = False;
  if (argc == 1):
    print("No arguments given");
    return 1;
  elif (argc == 2):
    print("No binary filename given");
    return 1;
  if (argc == 3):
    progname = argv[1];
    outname = argv[2];
  elif (argc == 4):
    if (argv[1] == "-d"):
      diskmode = True;
    else:
      print(f"\033[31mUnknown\033[0m argument `{argv[1]}`");
      return 1;
    progname = argv[2];
    outname = argv[3];

  with open(progname, "r") as fl:
    src = fl.read();
  src = RemEmpty(src)+"\0";
  tokens, exitcode = Lex(src);
  PrintTokens(tokens);
  print(tokens);
  ast, labs = Parse(tokens);
  PrintAst(ast);
  PrintLabs(labs);
  c, exitcode = CompileGC16X(ast, labs);
  with open(outname, "wb") as fl:
    fl.write(c);

  return 0;

sys.exit(main(len(sys.argv), sys.argv));

